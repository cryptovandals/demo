import './Vandalize.svelte.css.proxy.js';
/* src/Vandalize.svelte generated by Svelte v3.35.0 */
import {
	SvelteComponent,
	append,
	attr,
	binding_callbacks,
	detach,
	element,
	init,
	insert,
	listen,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text
} from "../_snowpack/pkg/svelte/internal.js";

import { ipfsAdd, toGateway } from "./ipfs.js";

function create_else_block(ctx) {
	let t;

	return {
		c() {
			t = text("Working, please wait...");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (110:4) {#if state === "idle"}
function create_if_block(ctx) {
	let button;
	let t1;
	let input;
	let t2;
	let label;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = "Liberate";
			t1 = space();
			input = element("input");
			t2 = space();
			label = element("label");
			label.textContent = "Vandalize";
			attr(input, "type", "file");
			attr(input, "id", "image-file");
			attr(input, "name", "image");
			attr(label, "for", "image-file");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			insert(target, t1, anchor);
			insert(target, input, anchor);
			/*input_binding*/ ctx[9](input);
			insert(target, t2, anchor);
			insert(target, label, anchor);

			if (!mounted) {
				dispose = [
					listen(button, "click", /*click_handler*/ ctx[8]),
					listen(input, "change", /*change_handler*/ ctx[10])
				];

				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			if (detaching) detach(t1);
			if (detaching) detach(input);
			/*input_binding*/ ctx[9](null);
			if (detaching) detach(t2);
			if (detaching) detach(label);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let div4;
	let div0;
	let h2;
	let t0_value = /*fromToken*/ ctx[0].metadata.name + "";
	let t0;
	let t1;
	let code;
	let t2;
	let t3_value = /*fromToken*/ ctx[0].uri + "";
	let t3;
	let t4;
	let pre0;
	let t5_value = JSON.stringify(/*fromToken*/ ctx[0].metadata, null, 4) + "";
	let t5;
	let t6;
	let div1;
	let t7;
	let div2;
	let pre1;
	let t8_value = /*logs*/ ctx[1].join("\n") + "";
	let t8;
	let t9;
	let div3;
	let img;
	let img_src_value;
	let img_alt_value;

	function select_block_type(ctx, dirty) {
		if (/*state*/ ctx[4] === "idle") return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	return {
		c() {
			div4 = element("div");
			div0 = element("div");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			code = element("code");
			t2 = text("Token URI: ");
			t3 = text(t3_value);
			t4 = space();
			pre0 = element("pre");
			t5 = text(t5_value);
			t6 = space();
			div1 = element("div");
			if_block.c();
			t7 = space();
			div2 = element("div");
			pre1 = element("pre");
			t8 = text(t8_value);
			t9 = space();
			div3 = element("div");
			img = element("img");
			attr(div0, "class", "header svelte-1qflc1w");
			attr(div1, "class", "header svelte-1qflc1w");
			attr(div2, "class", "log svelte-1qflc1w");
			if (img.src !== (img_src_value = /*fromToken*/ ctx[0].metadata.image)) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*fromToken*/ ctx[0].metadata.description);
			attr(img, "class", "svelte-1qflc1w");
			attr(div3, "class", "body svelte-1qflc1w");
			attr(div4, "class", "token svelte-1qflc1w");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			append(div4, div0);
			append(div0, h2);
			append(h2, t0);
			append(div0, t1);
			append(div0, code);
			append(code, t2);
			append(code, t3);
			append(div0, t4);
			append(div0, pre0);
			append(pre0, t5);
			append(div4, t6);
			append(div4, div1);
			if_block.m(div1, null);
			append(div4, t7);
			append(div4, div2);
			append(div2, pre1);
			append(pre1, t8);
			append(div4, t9);
			append(div4, div3);
			append(div3, img);
			/*img_binding*/ ctx[11](img);
		},
		p(ctx, [dirty]) {
			if (dirty & /*fromToken*/ 1 && t0_value !== (t0_value = /*fromToken*/ ctx[0].metadata.name + "")) set_data(t0, t0_value);
			if (dirty & /*fromToken*/ 1 && t3_value !== (t3_value = /*fromToken*/ ctx[0].uri + "")) set_data(t3, t3_value);
			if (dirty & /*fromToken*/ 1 && t5_value !== (t5_value = JSON.stringify(/*fromToken*/ ctx[0].metadata, null, 4) + "")) set_data(t5, t5_value);

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div1, null);
				}
			}

			if (dirty & /*logs*/ 2 && t8_value !== (t8_value = /*logs*/ ctx[1].join("\n") + "")) set_data(t8, t8_value);

			if (dirty & /*fromToken*/ 1 && img.src !== (img_src_value = /*fromToken*/ ctx[0].metadata.image)) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*fromToken*/ 1 && img_alt_value !== (img_alt_value = /*fromToken*/ ctx[0].metadata.description)) {
				attr(img, "alt", img_alt_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div4);
			if_block.d();
			/*img_binding*/ ctx[11](null);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	
	let { fromToken } = $$props;
	let { vandalizer } = $$props;
	let logs = [];
	let imageElement;
	let uploadElement;
	let state = "idle";

	function log(s) {
		console.log(s);
		$$invalidate(1, logs = [...logs, s]);
	}

	async function handleLiberate() {
		$$invalidate(4, state = "working");
		log(`Get original image from ${fromToken.metadata.image}`);
		const imageReq = await fetch(fromToken.metadata.image);
		const image = await imageReq.blob();
		await handleVandalize(image);
		$$invalidate(4, state = "idle");
	}

	async function handleVandalize(image) {
		let size;

		if (image instanceof ArrayBuffer) {
			size = image.byteLength;
		} else {
			size = image.size;
		}

		log(`Got image, size ${size} bytes`);
		const cid = await ipfsAdd(image);
		log(`Image uploaded to IPFS, CID ${cid}`);
		log(`Making metadata PERMANENT!)`);

		const metadata = {
			...fromToken.metadata,
			image: toGateway(cid)
		};

		log(`New metadata`);
		log(JSON.stringify(metadata, null, 4));
		const metadataCid = await ipfsAdd(JSON.stringify(metadata, null, 4));
		log(`Metadata uploaded to IPFS, CID ${metadataCid}`);
		log("Ask our valued customer to sign the approve tx");
		const approveTx = await fromToken.contract.approve(vandalizer.address, fromToken.id);
		log(`Approve tx hash ${approveTx.hash}`);
		const approveReceipt = await approveTx.wait();
		log(`Tx included in block ${approveReceipt.blockNumber}`);
		log(`${fromToken.contract.address}, ${fromToken.id}, ${toGateway(metadataCid)}`);
		await vandalizer.vandalize(fromToken.contract.address, fromToken.id, toGateway(metadataCid));
	}

	async function handleUpload() {
		$$invalidate(4, state = "working");

		if (!uploadElement.files) {
			return;
		}

		const fileReaderDataUrl = new FileReader();
		const fileReaderBinary = new FileReader();
		const [file] = uploadElement.files;

		fileReaderDataUrl.onload = () => {
			$$invalidate(2, imageElement.src = fileReaderDataUrl.result, imageElement);
		};

		fileReaderDataUrl.readAsDataURL(file);

		fileReaderBinary.onload = async () => {
			try {
				await handleVandalize(fileReaderBinary.result);
			} catch(e) {
				console.error(e);
				throw e;
			}
		};

		fileReaderBinary.readAsArrayBuffer(file);
		$$invalidate(4, state = "idle");
	}

	const click_handler = () => handleLiberate();

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			uploadElement = $$value;
			$$invalidate(3, uploadElement);
		});
	}

	const change_handler = e => handleUpload();

	function img_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			imageElement = $$value;
			$$invalidate(2, imageElement);
		});
	}

	$$self.$$set = $$props => {
		if ("fromToken" in $$props) $$invalidate(0, fromToken = $$props.fromToken);
		if ("vandalizer" in $$props) $$invalidate(7, vandalizer = $$props.vandalizer);
	};

	return [
		fromToken,
		logs,
		imageElement,
		uploadElement,
		state,
		handleLiberate,
		handleUpload,
		vandalizer,
		click_handler,
		input_binding,
		change_handler,
		img_binding
	];
}

class Vandalize extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { fromToken: 0, vandalizer: 7 });
	}
}

export default Vandalize;